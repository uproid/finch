---
doc_meta:
    group: "Kernconcepten"
    icon: "ph-bold ph-shield-check"
---
# Auth Controller Gids

Welkom bij de Finch Auth Controller Gids! Deze gids legt uit hoe je een Auth Controller maakt en gebruikt in je Finch-applicatie. Of je nu een ervaren ontwikkelaar bent of net begint, Finch biedt gereedschappen om authenticatie en autorisatie te beheren.

## Wat is een Auth Controller?

Een Auth Controller in Finch is een klasse die authenticatie en autorisatie afhandelt voor je applicatie. Het is verantwoordelijk voor het verwerken van authenticatieverzoeken, het beheren van gebruikerssessies en het controleren van gebruikersrechten. Auth Controllers worden gebruikt om je applicatie te beveiligen en te garanderen dat alleen geautoriseerde gebruikers toegang krijgen tot bepaalde resources.

## Een Auth Controller maken

De `AuthController` klasse is een abstracte klasse die je uitbreidt om je eigen Auth Controller te maken. De `AuthController` biedt een set methoden die je kunt overschrijven om de authenticatielogica van je applicatie aan te passen. Deze klasse breidt de `Controller` klasse uit, dus je kunt alle functies van `Controller` ook in je Auth Controller gebruiken.

Om een Auth Controller te maken, breid je de `AuthController` klasse uit. Hieronder een voorbeeld van een eenvoudige Auth Controller:

**Opmerking:** `User` is een type gebruiker-model dat je wilt gebruiken in je applicatie. Je kunt hiervoor elk type gebruiken.

Controleer het voorbeeld in het Finch voorbeeldproject: [example/lib/controllers/auth_controller.dart](https://github.com/uproid/finch/blob/master/example/lib/controllers/auth_controller.dart)

```dart
class AppAuthController extends AuthController<User> {
    @override
  Future<bool> auth() async {
    return true;
  }

  @override
  Future<bool> authApi() async {
    return true;
  }

  @override
  Future<
      ({
        bool success,
        String message,
        User? user,
      })> checkLogin() async {
    return (
      success: true,
      message: 'Please login.',
      user: User(),
    );
  }

  @override
  Future<bool> checkPermission() async {
    return true;
  }

  @override
  Future<String> loginPost() async {
    return rq.renderString(text: "TEST", status: 403);
  }

  @override
  Future<String> logout() {
    return rq.renderString(text: "LOGOUT", status: 403);
  }

  @override
  void removeAuth() {
    // TODO: implement removeAuth
  }

  @override
  void updateAuth(String email, String password, User user) {
    // TODO: implement updateAuth
  }

  @override
  Future<String> newUser() {
    throw UnimplementedError();
  }

  @override
  Future<String> register() {
    throw UnimplementedError();
  }

  @override
  void removeAuth() {
    rq.session.remove('user');
    rq.removeCookie('user');
    userLogined = null;
  }

  @override
  void updateAuth(String email, String password, User user) {
    userLogined = user;
    rq.addSession('user', email);
  }
}
```